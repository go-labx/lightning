
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>lightning: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/go-labx/lightning/context.go (0.0%)</option>
				
				<option value="file1">github.com/go-labx/lightning/context_data.go (100.0%)</option>
				
				<option value="file2">github.com/go-labx/lightning/cookie.go (100.0%)</option>
				
				<option value="file3">github.com/go-labx/lightning/lightning.go (0.0%)</option>
				
				<option value="file4">github.com/go-labx/lightning/request.go (100.0%)</option>
				
				<option value="file5">github.com/go-labx/lightning/response.go (0.0%)</option>
				
				<option value="file6">github.com/go-labx/lightning/router.go (88.9%)</option>
				
				<option value="file7">github.com/go-labx/lightning/util.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package lightning

import (
        "net/http"
)

type Context struct {
        request  *Request
        response *Response
        data     ContextData
        Method   string
        Path     string
}

// NewContext creates a new context object with the given HTTP response writer and request.
func NewContext(writer http.ResponseWriter, req *http.Request, params map[string]string) *Context <span class="cov0" title="0">{
        request := NewRequest(req, params)
        response := NewResponse(req, writer)
        ctx := &amp;Context{
                request:  request,
                response: response,
                data:     ContextData{},
                Method:   request.method,
                Path:     request.path,
        }

        return ctx
}</span>

// Param returns the parameter value for a given key.
func (c *Context) Param(key string) string <span class="cov0" title="0">{
        return c.request.Param(key)
}</span>

// Params returns the entire parameter map for the context.
func (c *Context) Params() map[string]string <span class="cov0" title="0">{
        return c.request.Params()
}</span>

// Query returns the value of a given query parameter.
func (c *Context) Query(key string) string <span class="cov0" title="0">{
        return c.request.Query(key)
}</span>

func (c *Context) Queries() map[string][]string <span class="cov0" title="0">{
        return c.request.Queries()
}</span>

func (c *Context) Status() int <span class="cov0" title="0">{
        return c.response.status
}</span>

// SetStatus sets the HTTP status code for the response.
func (c *Context) SetStatus(code int) <span class="cov0" title="0">{
        c.response.SetStatus(code)
}</span>

// Header returns the value of a given header.
func (c *Context) Header(key string) string <span class="cov0" title="0">{
        return c.request.Header(key)
}</span>

// Headers returns the entire header map for the request.
func (c *Context) Headers() http.Header <span class="cov0" title="0">{
        return c.request.Headers()
}</span>

// AddHeader adds a new header key-value pair to the response.
func (c *Context) AddHeader(key, value string) <span class="cov0" title="0">{
        c.response.AddHeader(key, value)
}</span>

// SetHeader sets the value of a given header in the response.
func (c *Context) SetHeader(key string, value string) <span class="cov0" title="0">{
        c.response.SetHeader(key, value)
}</span>

// DelHeader deletes a given header from the response.
func (c *Context) DelHeader(key string) <span class="cov0" title="0">{
        c.response.DelHeader(key)
}</span>

// Cookie returns the cookie with the given name.
func (c *Context) Cookie(name string) *http.Cookie <span class="cov0" title="0">{
        return c.request.Cookie(name)
}</span>

// Cookies returns all cookies from the request.
func (c *Context) Cookies() []*http.Cookie <span class="cov0" title="0">{
        return c.request.Cookies()
}</span>

// SetCookie sets a new cookie with the given key-value pair.
func (c *Context) SetCookie(key string, value string) <span class="cov0" title="0">{
        c.response.Cookies.Set(key, value)
}</span>

// SetCustomCookie sets a custom cookie in the response.
func (c *Context) SetCustomCookie(cookie *http.Cookie) <span class="cov0" title="0">{
        c.response.Cookies.SetCustom(cookie)
}</span>

// JSON writes a JSON response with the given status code and object.
func (c *Context) JSON(obj interface{}) <span class="cov0" title="0">{
        c.response.SetStatus(http.StatusOK)
        err := c.response.JSON(obj)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
}

// Text writes a plain text response with the given status code and format.
func (c *Context) Text(text string) <span class="cov0" title="0">{
        c.response.SetStatus(http.StatusOK)
        c.response.Text(text)
}</span>

func (c *Context) NotFound() <span class="cov0" title="0">{
        c.response.SetStatus(http.StatusNotFound)
        c.response.Text(http.StatusText(http.StatusNotFound))
}</span>

func (c *Context) GetData(key string) interface{} <span class="cov0" title="0">{
        return c.data.Get(key)
}</span>

func (c *Context) SetData(key string, value interface{}) <span class="cov0" title="0">{
        c.data.Set(key, value)
}</span>

func (c *Context) DelData(key string) <span class="cov0" title="0">{
        c.data.Del(key)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package lightning

// ContextData is a map[string]interface{} that can be used to store data in the context of a request.
type ContextData map[string]interface{}

// Get retrieves the value associated with the given key from the ContextData.
func (c ContextData) Get(key string) interface{} <span class="cov8" title="1">{
        return c[key]
}</span>

// Set sets the value associated with the given key in the ContextData.
func (c ContextData) Set(key string, value interface{}) <span class="cov8" title="1">{
        c[key] = value
}</span>

// Del deletes the value associated with the given key from the ContextData.
func (c ContextData) Del(key string) <span class="cov8" title="1">{
        delete(c, key)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package lightning

import (
        "net/http"
)

// Cookies is a map of http.Cookie pointers.
type Cookies map[string]*http.Cookie

// Get returns the http.Cookie pointer with the given key.
func (cookies Cookies) Get(key string) *http.Cookie <span class="cov8" title="1">{
        return cookies[key]
}</span>

// Set sets the http.Cookie with the given key and value.
func (cookies Cookies) Set(key string, value string) <span class="cov8" title="1">{
        cookies[key] = &amp;http.Cookie{
                Name:  key,
                Value: value,
                Path:  "/",
        }
}</span>

// Del deletes the http.Cookie with the given key.
func (cookies Cookies) Del(key string) <span class="cov8" title="1">{
        delete(cookies, key)
}</span>

// SetCustom sets the given http.Cookie pointer.
func (cookies Cookies) SetCustom(cookie *http.Cookie) <span class="cov8" title="1">{
        cookies[cookie.Name] = cookie
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package lightning

import (
        "fmt"
        "github.com/go-labx/lightlog"
        "net/http"
)

// Compose takes multiple MiddlewareFuns and returns a single MiddlewareFunc.
// The returned MiddlewareFunc executes each MiddlewareFunc in the order they are passed,
// and then executes the `next` function.
func Compose(mw ...MiddlewareFunc) MiddlewareFunc <span class="cov0" title="0">{
        return func(c *Context, next Next) </span><span class="cov0" title="0">{
                var recursive func(i int)
                recursive = func(i int) </span><span class="cov0" title="0">{
                        if i &lt; len(mw) </span><span class="cov0" title="0">{
                                // Execute the current middleware and pass the `next` function recursively.
                                mw[i](c, func() </span><span class="cov0" title="0">{
                                        recursive(i + 1)
                                }</span>)
                        } else<span class="cov0" title="0"> {
                                // Execute the `next` function when all middlewares have been executed.
                                next()
                        }</span>
                }
                <span class="cov0" title="0">recursive(0)</span>
        }
}

// Next is a function type that represents the next middleware in the chain.
type Next func()

// HandlerFunc is a function type that represents the actual handler function for a route.
type HandlerFunc func(*Context)

// MiddlewareFunc is a function type that represents a middleware function.
type MiddlewareFunc func(ctx *Context, next Next)

type Application struct {
        router      *Router
        middlewares []MiddlewareFunc
        logger      *lightlog.ConsoleLogger
}

// App returns a new instance of the Application struct.
func App() *Application <span class="cov0" title="0">{
        return &amp;Application{
                router:      NewRouter(),
                middlewares: make([]MiddlewareFunc, 0),
                logger:      lightlog.NewConsoleLogger("logger", lightlog.TRACE),
        }
}</span>

// Use adds one or more MiddlewareFuncs to the array of middlewares in the Application struct.
func (app *Application) Use(middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.middlewares = append(app.middlewares, middlewares...)
}</span>

// AddRoute is a function that adds a new route to the Router.
// It composes the global middlewares, route-specific middlewares, and the actual handler function
// to form a single MiddlewareFunc, and then adds it to the Router.
func (app *Application) AddRoute(method string, pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.logger.Trace("register route %s\t-&gt; %s", method, pattern)

        fn := Compose(Compose(app.middlewares...), Compose(middlewares...), func(ctx *Context, next Next) </span><span class="cov0" title="0">{
                handler(ctx)
        }</span>)

        <span class="cov0" title="0">app.router.AddRoute(method, pattern, func(ctx *Context) </span><span class="cov0" title="0">{
                fn(ctx, nil)
        }</span>)
}

// The following functions are shortcuts for the AddRoute function.
// They pre-fill the method parameter and call the AddRoute function.

func (app *Application) Get(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("GET", pattern, handler, middlewares...)
}</span>

func (app *Application) Post(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("POST", pattern, handler, middlewares...)
}</span>

func (app *Application) Put(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("PUT", pattern, handler, middlewares...)
}</span>

func (app *Application) Delete(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("DELETE", pattern, handler, middlewares...)
}</span>

func (app *Application) Head(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("HEAD", pattern, handler, middlewares...)
}</span>

func (app *Application) Patch(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("PATCH", pattern, handler, middlewares...)
}</span>

func (app *Application) Options(pattern string, handler HandlerFunc, middlewares ...MiddlewareFunc) <span class="cov0" title="0">{
        app.AddRoute("OPTIONS", pattern, handler, middlewares...)
}</span>

// ServeHTTP is the function that handles HTTP requests.
// It finds the matching route, creates a new Context, sets the route parameters,
// and executes the MiddlewareFunc chain.
func (app *Application) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if handler, params := app.router.FindRoute(req.Method, req.URL.Path); handler != nil </span><span class="cov0" title="0">{
                ctx := NewContext(w, req, params)
                handler(ctx)
                defer ctx.response.flush()
        }</span> else<span class="cov0" title="0"> {
                w.WriteHeader(http.StatusNotFound)
                _, err := fmt.Fprintf(w, "404 Not Found: %s", req.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// Run starts the HTTP server and listens for incoming requests.
func (app *Application) Run() <span class="cov0" title="0">{
        addr := "127.0.0.1:6789"
        app.logger.Info("Starting application on address `%s` 🚀🚀🚀", addr)

        err := http.ListenAndServe(addr, app)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package lightning

import "net/http"

type Request struct {
        req    *http.Request
        params map[string]string
        method string
        path   string
}

func NewRequest(req *http.Request, params map[string]string) *Request <span class="cov8" title="1">{
        request := &amp;Request{
                req:    req,
                params: params,
                method: req.Method,
                path:   req.URL.Path,
        }

        return request
}</span>

// Param returns the parameter value for a given key.
func (r *Request) Param(key string) string <span class="cov8" title="1">{
        return r.params[key]
}</span>

// Params returns the entire parameter map for the context.
func (r *Request) Params() map[string]string <span class="cov8" title="1">{
        return r.params
}</span>

// Query returns the value of a given query parameter.
func (r *Request) Query(key string) string <span class="cov8" title="1">{
        return r.req.URL.Query().Get(key)
}</span>

func (r *Request) Queries() map[string][]string <span class="cov8" title="1">{
        return r.req.URL.Query()
}</span>

// Header returns the value of a given header.
func (r *Request) Header(key string) string <span class="cov8" title="1">{
        return r.req.Header.Get(key)
}</span>

// Headers returns the entire header map for the request.
func (r *Request) Headers() http.Header <span class="cov8" title="1">{
        return r.req.Header
}</span>

// Cookie returns the cookie with the given name.
func (r *Request) Cookie(name string) *http.Cookie <span class="cov8" title="1">{
        cookie, err := r.req.Cookie(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cookie</span>
}

// Cookies returns all cookies from the request.
func (r *Request) Cookies() []*http.Cookie <span class="cov8" title="1">{
        return r.req.Cookies()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package lightning

import (
        "encoding/json"
        "encoding/xml"
        "net/http"
        "os"
        "path/filepath"
)

// Response Declaring the Response structure that will be used to hold HTTP response data.
type Response struct {
        req      *http.Request       // A pointer to an HTTP request.
        res      http.ResponseWriter // An HTTP response writer.
        status   int                 // The status code of the HTTP response (e.g. 200, 404, 500, etc.).
        Cookies  Cookies             // An array of cookies to be sent with the HTTP response.
        data     []byte              // The response data to be sent.
        redirect string              // The URL to redirect to.
        file     string              // The file to send.
}

// NewResponse A constructor function for the Response structure.
func NewResponse(req *http.Request, res http.ResponseWriter) *Response <span class="cov0" title="0">{
        response := &amp;Response{
                req:      req,
                res:      res,
                status:   http.StatusNotFound,
                Cookies:  Cookies{},
                data:     nil,
                redirect: "",
        }
        return response
}</span>

func (r *Response) SetStatus(code int) <span class="cov0" title="0">{
        r.status = code
}</span>

// JSON A method for marshaling a JSON object and setting the appropriate headers.
func (r *Response) JSON(obj interface{}) error <span class="cov0" title="0">{
        res, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.res.Header().Set("Content-Type", "application/json")

        r.Raw(res)
        return nil</span>
}

// XML A method for marshaling an XML object and setting the appropriate headers.
func (r *Response) XML(obj interface{}) error <span class="cov0" title="0">{
        res, err := xml.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">r.res.Header().Set("Content-Type", "application/xml")
        r.Raw(res)
        return nil</span>
}

// Text A method for setting plain text as the response data.
func (r *Response) Text(text string) <span class="cov0" title="0">{
        r.Raw([]byte(text))
}</span>

// Raw A method for setting the response data directly.
func (r *Response) Raw(data []byte) <span class="cov0" title="0">{
        r.data = data
}</span>

// Redirect A method for setting a redirect URL.
func (r *Response) Redirect(url string) <span class="cov0" title="0">{
        r.redirect = url
}</span>

// File A method for serving a file.
func (r *Response) File(path string) error <span class="cov0" title="0">{
        absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err = os.Stat(absPath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.file = absPath
        return nil</span>
}

// AddHeader adds a new header key-value pair to the response.
func (r *Response) AddHeader(key, value string) <span class="cov0" title="0">{
        r.res.Header().Add(key, value)
}</span>

// SetHeader sets the value of a given header in the response.
func (r *Response) SetHeader(key string, value string) <span class="cov0" title="0">{
        r.res.Header().Set(key, value)
}</span>

// DelHeader deletes a given header from the response.
func (r *Response) DelHeader(key string) <span class="cov0" title="0">{
        r.res.Header().Del(key)
}</span>

func (r *Response) sendFile() <span class="cov0" title="0">{
        base := filepath.Base(r.file)
        r.res.Header().Set("Content-Disposition", "attachment; filename="+base)
        http.ServeFile(r.res, r.req, r.file)
}</span>

// A method for sending the HTTP response.
func (r *Response) flush() <span class="cov0" title="0">{
        for _, v := range r.Cookies </span><span class="cov0" title="0">{
                http.SetCookie(r.res, v)
        }</span>

        <span class="cov0" title="0">if len(r.file) &gt; 0 </span><span class="cov0" title="0">{
                r.sendFile()
        }</span> else<span class="cov0" title="0"> if len(r.redirect) &gt; 0 </span><span class="cov0" title="0">{
                http.Redirect(r.res, r.req, r.redirect, r.status)
        }</span> else<span class="cov0" title="0"> {
                r.res.WriteHeader(r.status)
                _, err := r.res.Write(r.data)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package lightning is a Go library that provides a lightweight, high-perform
package lightning

import (
        "net/http"
        "strings"
)

// TrieNode represents a node in the trie data structure used by the router.
type TrieNode struct {
        children map[string]*TrieNode // A map of child nodes keyed by their string values
        isEnd    bool                 // boolean flag indicating whether the node marks the end of a route
        handler  HandlerFunc          // a `HandlerFunc` function that handles requests for the node's route
        params   map[string]int       // a map of parameter names and their corresponding indices in the route pattern
        wildcard string               // a string representing the name of the wildcard parameter in the route pattern (if any)
}

// Router represents the HTTP router.
type Router struct {
        roots map[string]*TrieNode
}

// NewTrieNode creates a new instance of the `TrieNode` struct with default values.
func NewTrieNode() *TrieNode <span class="cov8" title="1">{
        return &amp;TrieNode{
                children: make(map[string]*TrieNode),
                isEnd:    false,
                handler:  nil,
                params:   make(map[string]int),
                wildcard: "",
        }
}</span>

// NewRouter creates a new instance of the `Router` struct with an empty `roots` map.
func NewRouter() *Router <span class="cov8" title="1">{
        return &amp;Router{
                roots: make(map[string]*TrieNode),
        }
}</span>

// AddRoute adds a new route to the router.
func (r *Router) AddRoute(method string, pattern string, handler HandlerFunc) <span class="cov8" title="1">{
        if !isValidHTTPMethod(method) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">root, ok := r.roots[method]
        if !ok </span><span class="cov8" title="1">{
                root = NewTrieNode()
                r.roots[method] = root
        }</span>

        <span class="cov8" title="1">params := make(map[string]int)
        parts := ParsePattern(pattern)
        for i, part := range parts </span><span class="cov8" title="1">{
                if part[0] == ':' </span><span class="cov8" title="1">{
                        // parameter
                        name := part[1:]
                        params[name] = i
                        if root.children[":"] == nil </span><span class="cov8" title="1">{
                                root.children[":"] = NewTrieNode()
                        }</span>
                        <span class="cov8" title="1">root = root.children[":"]</span>
                } else<span class="cov8" title="1"> if part[0] == '*' </span><span class="cov8" title="1">{
                        // wildcard
                        name := part[1:]
                        if root.children["*"] == nil </span><span class="cov8" title="1">{
                                root.children["*"] = NewTrieNode()
                        }</span>
                        <span class="cov8" title="1">root = root.children["*"]
                        root.wildcard = name
                        break</span>
                } else<span class="cov8" title="1"> {
                        // static
                        if root.children[part] == nil </span><span class="cov8" title="1">{
                                root.children[part] = NewTrieNode()
                        }</span>
                        <span class="cov8" title="1">root = root.children[part]</span>
                }
        }

        <span class="cov8" title="1">root.isEnd = true
        root.handler = handler
        root.params = params</span>
}

// FindRoute is used to find the appropriate handler function for a given HTTP request method and URL pattern.
func (r *Router) FindRoute(method string, pattern string) (HandlerFunc, map[string]string) <span class="cov8" title="1">{
        root, ok := r.roots[method]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">params := make(map[string]string)
        values := make(map[int]string)

        parts := ParsePattern(pattern)
        for i, part := range parts </span><span class="cov8" title="1">{
                if root.children[part] != nil </span><span class="cov8" title="1">{
                        root = root.children[part]
                }</span> else<span class="cov8" title="1"> if root.children[":"] != nil </span><span class="cov8" title="1">{
                        root = root.children[":"]
                        values[i] = part
                }</span> else<span class="cov8" title="1"> if root.children["*"] != nil </span><span class="cov8" title="1">{
                        root = root.children["*"]
                        if root.wildcard != "" </span><span class="cov8" title="1">{
                                params[root.wildcard] = strings.Join(parts[i:], "/")
                        }</span>
                        <span class="cov8" title="1">break</span>
                } else<span class="cov8" title="1"> {
                        return nil, nil
                }</span>
        }

        <span class="cov8" title="1">if !root.isEnd </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">for name, index := range root.params </span><span class="cov8" title="1">{
                params[name] = values[index]
        }</span>

        <span class="cov8" title="1">return root.handler, params</span>
}

// HTTP Method Functions

// Get adds a GET route to the router.
func (r *Router) Get(path string, handler HandlerFunc) <span class="cov8" title="1">{
        r.AddRoute(http.MethodGet, path, handler)
}</span>

// Post adds a POST route to the router.
func (r *Router) Post(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodPost, path, handler)
}</span>

// Put adds a PUT route to the router.
func (r *Router) Put(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodPut, path, handler)
}</span>

// Delete adds a DELETE route to the router.
func (r *Router) Delete(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodDelete, path, handler)
}</span>

// Head adds a HEAD route to the router.
func (r *Router) Head(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodHead, path, handler)
}</span>

// Patch adds a PATCH route to the router.
func (r *Router) Patch(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodPatch, path, handler)
}</span>

// Options adds an OPTIONS route to the router.
func (r *Router) Options(path string, handler HandlerFunc) <span class="cov0" title="0">{
        r.AddRoute(http.MethodOptions, path, handler)
}</span>

func isValidHTTPMethod(method string) bool <span class="cov8" title="1">{
        switch method </span>{
        case "GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package lightning

import (
        "strings"
)

// ParsePattern splits a route pattern string into its individual parts.
func ParsePattern(pattern string) []string <span class="cov8" title="1">{
        parts := strings.Split(pattern, "/")
        result := make([]string, 0)
        for _, part := range parts </span><span class="cov8" title="1">{
                if part != "" </span><span class="cov8" title="1">{
                        result = append(result, part)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
